"""
Auto-generated scraper for Ranchi - complaint_form
URL: https://smartranchi.in/Portal/View/ComplaintRegistration.aspx?m=Online
Generated: N/A

This scraper was automatically generated by AI based on website analysis.
It may require adjustments if the website structure changes.

Analysis Summary:
{
  "municipality": "ranchi_complaint_form",
  "page_title": "RMC",
  "final_url": "https://smartranchi.in/Portal/View/ComplaintRegistration.aspx?m=Online"
}
"""

import asyncio
import logging
import os
import re
from datetime import datetime
from typing import Optional
from playwright.async_api import async_playwright, Page, Browser, BrowserContext, TimeoutError as PlaywrightTimeoutError

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('RanchiScraper')


class RanchiScraper:
    """Production-ready Playwright scraper for Ranchi Municipality grievance form."""
    
    BASE_URL = "https://smartranchi.in/Portal/View/ComplaintRegistration.aspx?m=Online"
    
    def __init__(self, headless: bool = True, screenshot_dir: str = "./screenshots"):
        """
        Initialize the scraper.
        
        Args:
            headless: Run browser in headless mode (default: True)
            screenshot_dir: Directory to save screenshots
        """
        self.headless = headless
        self.screenshot_dir = screenshot_dir
        self.browser: Optional[Browser] = None
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.screenshots: list = []
        
        # Ensure screenshot directory exists
        os.makedirs(screenshot_dir, exist_ok=True)
    
    async def _init_browser(self):
        """Initialize browser with stealth settings."""
        playwright = await async_playwright().start()
        
        # Launch browser with stealth settings
        self.browser = await playwright.chromium.launch(
            headless=self.headless,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--disable-dev-shm-usage',
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-web-security',
                '--disable-features=IsolateOrigins,site-per-process'
            ]
        )
        
        # Create context with realistic settings
        self.context = await self.browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            locale='en-IN',
            timezone_id='Asia/Kolkata',
            permissions=['geolocation'],
            geolocation={'latitude': 23.3441, 'longitude': 85.3096},  # Ranchi coordinates
            extra_http_headers={
                'Accept-Language': 'en-IN,en;q=0.9,hi;q=0.8',
                'Accept-Encoding': 'gzip, deflate, br',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'
            }
        )
        
        # Add stealth scripts
        await self.context.add_init_script("""
            // Override webdriver property
            Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined
            });
            
            // Override plugins
            Object.defineProperty(navigator, 'plugins', {
                get: () => [1, 2, 3, 4, 5]
            });
            
            // Override languages
            Object.defineProperty(navigator, 'languages', {
                get: () => ['en-IN', 'en', 'hi']
            });
            
            // Override platform
            Object.defineProperty(navigator, 'platform', {
                get: () => 'Win32'
            });
            
            // Override chrome
            window.chrome = {
                runtime: {}
            };
        """)
        
        self.page = await self.context.new_page()
        
        # Set default timeout
        self.page.set_default_timeout(30000)
        
        logger.info("Browser initialized with stealth settings")
    
    async def _take_screenshot(self, step_name: str) -> str:
        """Take a screenshot and save it."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.screenshot_dir}/ranchi_{step_name}_{timestamp}.png"
        await self.page.screenshot(path=filename, full_page=True)
        self.screenshots.append(filename)
        logger.info(f"Screenshot saved: {filename}")
        return filename
    
    async def _wait_for_page_load(self):
        """Wait for page to fully load."""
        try:
            await self.page.wait_for_load_state('networkidle', timeout=15000)
        except PlaywrightTimeoutError:
            logger.warning("Network idle timeout, continuing...")
        await self.page.wait_for_load_state('domcontentloaded')
        await asyncio.sleep(1)  # Additional wait for dynamic content
    
    async def _navigate_to_form(self) -> bool:
        """Navigate to the grievance form."""
        try:
            logger.info(f"Navigating to: {self.BASE_URL}")
            await self.page.goto(self.BASE_URL, wait_until='domcontentloaded')
            await self._wait_for_page_load()
            await self._take_screenshot("01_initial_page")
            
            # Verify we're on the correct page
            title = await self.page.title()
            logger.info(f"Page title: {title}")
            
            return True
        except Exception as e:
            logger.error(f"Navigation failed: {str(e)}")
            return False
    
    async def _select_dropdown_option(self, selector: str, value: str, field_name: str) -> bool:
        """Select an option from a dropdown by visible text or value."""
        try:
            # Wait for the dropdown to be visible
            await self.page.wait_for_selector(selector, state='visible', timeout=10000)
            
            # Get all options
            options = await self.page.query_selector_all(f"{selector} option")
            
            for option in options:
                option_text = await option.inner_text()
                option_value = await option.get_attribute('value')
                
                if value.lower() in option_text.lower() or value == option_value:
                    await self.page.select_option(selector, label=option_text)
                    logger.info(f"Selected '{option_text}' for {field_name}")
                    return True
            
            # If exact match not found, select first non-empty option
            for option in options:
                option_value = await option.get_attribute('value')
                option_text = await option.inner_text()
                if option_value and option_value != "" and "--" not in option_text:
                    await self.page.select_option(selector, value=option_value)
                    logger.warning(f"Exact match not found for {field_name}, selected: {option_text}")
                    return True
            
            logger.warning(f"Could not find suitable option for {field_name}")
            return False
            
        except Exception as e:
            logger.error(f"Error selecting dropdown {field_name}: {str(e)}")
            return False
    
    async def _fill_text_field(self, selector: str, value: str, field_name: str) -> bool:
        """Fill a text input field."""
        try:
            # Try multiple selector strategies
            selectors_to_try = [
                selector,
                f"input[id*='{field_name}']",
                f"input[name*='{field_name}']",
                f"textarea[id*='{field_name}']",
                f"textarea[name*='{field_name}']"
            ]
            
            for sel in selectors_to_try:
                try:
                    element = await self.page.query_selector(sel)
                    if element:
                        await element.click()
                        await element.fill('')  # Clear existing value
                        await element.type(value, delay=50)  # Type with human-like delay
                        logger.info(f"Filled {field_name} with value")
                        return True
                except Exception:
                    continue
            
            logger.warning(f"Could not find field: {field_name}")
            return False
            
        except Exception as e:
            logger.error(f"Error filling {field_name}: {str(e)}")
            return False
    
    async def _upload_file(self, file_path: str) -> bool:
        """Upload a file to the form."""
        try:
            if not file_path or not os.path.exists(file_path):
                logger.info("No file to upload or file not found")
                return True
            
            # Find file input
            file_input = await self.page.query_selector("input[type='file']")
            if file_input:
                await file_input.set_input_files(file_path)
                logger.info(f"File uploaded: {file_path}")
                
                # Wait for upload to complete
                await asyncio.sleep(2)
                
                # Click upload button if present
                upload_btn = await self.page.query_selector("button[class*='Upload'], input[value*='Upload']")
                if upload_btn:
                    await upload_btn.click()
                    await asyncio.sleep(2)
                
                return True
            else:
                logger.warning("File input not found")
                return False
                
        except Exception as e:
            logger.error(f"Error uploading file: {str(e)}")
            return False
    
    async def _fill_form(self, data: dict) -> bool:
        """Fill all form fields with provided data."""
        try:
            logger.info("Starting form fill...")
            
            # Map input data to form fields
            field_mappings = {
                'problem': {
                    'selector': "select[id*='Problem'], select[name*='Problem']",
                    'type': 'select',
                    'value': data.get('category', data.get('problem', ''))
                },
                'area': {
                    'selector': "select[id*='Area'], select[name*='Area']",
                    'type': 'select',
                    'value': data.get('area', data.get('locality', ''))
                },
                'name': {
                    'selector': "input[id*='Name'][id*='txt'], input[name*='Name']",
                    'type': 'text',
                    'value': data.get('name', '')
                },
                'mobile': {
                    'selector': "input[id*='Mobile'], input[name*='Mobile']",
                    'type': 'text',
                    'value': data.get('phone', data.get('mobile', ''))
                },
                'email': {
                    'selector': "input[id*='Email'][type='text'], input[name*='Email']",
                    'type': 'text',
                    'value': data.get('email', '')
                },
                'contact_person': {
                    'selector': "input[id*='ContactPerson'][id*='No'], input[name*='ContactPerson']",
                    'type': 'text',
                    'value': data.get('contact_person_no', data.get('phone', ''))
                },
                'contact_person_name': {
                    'selector': "input[id*='ContactPersonName'], input[name*='ContactPersonName']",
                    'type': 'text',
                    'value': data.get('contact_person_name', data.get('name', ''))
                },
                'address': {
                    'selector': "input[id*='Address'], input[name*='Address'], textarea[id*='Address']",
                    'type': 'text',
                    'value': data.get('address', '')
                },
                'remarks': {
                    'selector': "textarea[id*='Remarks'], textarea[name*='Remarks']",
                    'type': 'text',
                    'value': data.get('complaint', data.get('remarks', data.get('description', '')))
                },
                'tenament': {
                    'selector': "input[id*='Tenament'], input[name*='Tenament']",
                    'type': 'text',
                    'value': data.get('tenament_no', '')
                }
            }
            
            # Fill Problem dropdown first (required)
            if field_mappings['problem']['value']:
                await self._select_dropdown_option(
                    field_mappings['problem']['selector'],
                    field_mappings['problem']['value'],
                    'Problem'
                )
                await asyncio.sleep(1)
            
            # Fill Area dropdown (required)
            if field_mappings['area']['value']:
                await self._select_dropdown_option(
                    field_mappings['area']['selector'],
                    field_mappings['area']['value'],
                    'Area'
                )
                await asyncio.sleep(1)
            
            await self._take_screenshot("02_dropdowns_filled")
            
            # Fill text fields
            for field_name, field_info in field_mappings.items():
                if field_info['type'] == 'text' and field_info['value']:
                    await self._fill_text_field(
                        field_info['selector'],
                        field_info['value'],
                        field_name
                    )
                    await asyncio.sleep(0.5)
            
            await self._take_screenshot("03_form_filled")
            
            # Handle file upload if provided
            if data.get('file_path'):
                # Select file type if available
                file_type_selector = "select[id*='FileType'], select[name*='FileType']"
                file_type = await self.page.query_selector(file_type_selector)
                if file_type:
                    await self._select_dropdown_option(file_type_selector, 'Image', 'FileType')
                
                # Fill title if available
                title_value = data.get('file_title', 'Complaint Document')
                await self._fill_text_field("input[id*='Title'], input[name*='Title']", title_value, 'Title')
                
                # Upload file
                await self._upload_file(data['file_path'])
                await self._take_screenshot("04_file_uploaded")
            
            logger.info("Form fill completed")
            return True
            
        except Exception as e:
            logger.error(f"Error filling form: {str(e)}")
            await self._take_screenshot("error_form_fill")
            return False
    
    async def _submit_form(self) -> dict:
        """Submit the form and capture the result."""
        result = {
            'success': False,
            'tracking_id': None,
            'message': None,
            'error': None
        }
        
        try:
            logger.info("Submitting form...")
            
            # Find and click submit button
            submit_selectors = [
                "input[value*='Register']",
                "button[id*='Submit']",
                "input[type='submit']",
                "button.btn-primary",
                "input[value*='Submit']",
                "a[id*='Register']"
            ]
            
            submit_btn = None
            for selector in submit_selectors:
                submit_btn = await self.page.query_selector(selector)
                if submit_btn:
                    is_visible = await submit_btn.is_visible()
                    if is_visible:
                        logger.info(f"Found submit button with selector: {selector}")
                        break
                    submit_btn = None
            
            if not submit_btn:
                result['error'] = "Submit button not found"
                logger.error(result['error'])
                return result
            
            # Click submit and wait for response
            await submit_btn.click()
            
            # Wait for page response
            await asyncio.sleep(3)
            await self._wait_for_page_load()
            
            await self._take_screenshot("05_after_submit")
            
            # Check for success/error messages
            page_content = await self.page.content()
            page_text = await self.page.inner_text('body')
            
            # Look for tracking ID patterns
            tracking_patterns = [
                r'Complaint\s*(?:No|Number|ID)[:\s]*([A-Z0-9\-\/]+)',
                r'Reference\s*(?:No|Number|ID)[:\s]*([A-Z0-9\-\/]+)',
                r'Registration\s*(?:No|Number|ID)[:\s]*([A-Z0-9\-\/]+)',
                r'Token\s*(?:No|Number|ID)[:\s]*([A-Z0-9\-\/]+)',
                r'Ticket\s*(?:No|Number|ID)[:\s]*([A-Z0-9\-\/]+)',
                r'([A-Z]{2,4}[\/\-]?\d{4,}[\/\-]?\d*)'
            ]
            
            for pattern in tracking_patterns:
                match = re.search(pattern, page_text, re.IGNORECASE)
                if match:
                    result['tracking_id'] = match.group(1)
                    logger.info(f"Found tracking ID: {result['tracking_id']}")
                    break
            
            # Check for success indicators
            success_indicators = [
                'successfully',
                'registered',
                'submitted',
                'thank you',
                'complaint has been',
                'reference number'
            ]
            
            error_indicators = [
                'error',
                'failed',
                'invalid',
                'required',
                'please enter',
                'mandatory'
            ]
            
            page_text_lower = page_text.lower()
            
            if any(indicator in page_text_lower for indicator in success_indicators):
                result['success'] = True
                result['message'] = "Complaint registered successfully"
                logger.info("Form submitted successfully")
            elif any(indicator in page_text_lower for indicator in error_indicators):
                result['success'] = False
                # Try to extract error message
                error_elements = await self.page.query_selector_all(".error, .alert-danger, .validation-error, span[style*='color:red'], span[style*='color: red']")
                error_messages = []
                for elem in error_elements:
                    text = await elem.inner_text()
                    if text.strip():
                        error_messages.append(text.strip())
                result['error'] = "; ".join(error_messages) if error_messages else "Form submission failed"
                logger.error(f"Form submission error: {result['error']}")
            else:
                # Check if we're on a new page (success page)
                current_url = self.page.url
                if current_url != self.BASE_URL:
                    result['success'] = True
                    result['message'] = "Form submitted (redirected to new page)"
                else:
                    result['message'] = "Form submitted but status unclear"
            
            return result
            
        except Exception as e:
            result['error'] = str(e)
            logger.error(f"Error submitting form: {str(e)}")
            await self._take_screenshot("error_submit")
            return result
    
    async def _retry_operation(self, operation, max_retries: int = 3, delay: float = 2.0):
        """Retry an operation with exponential backoff."""
        last_error = None
        for attempt in range(max_retries):
            try:
                return await operation()
            except Exception as e:
                last_error = e
                logger.warning(f"Attempt {attempt + 1} failed: {str(e)}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(delay * (attempt + 1))
        raise last_error
    
    async def submit_grievance(self, data: dict) -> dict:
        """
        Submit a grievance to the Ranchi Municipality portal.
        
        Args:
            data: Dictionary containing grievance details:
                - name: Complainant name (required)
                - phone: Mobile number (required)
                - email: Email address (optional)
                - complaint: Complaint description (required)
                - category: Problem category (required)
                - area: Area/locality (required)
                - address: Residential address (optional)
                - contact_person_name: Contact person name (optional)
                - contact_person_no: Contact person number (optional)
                - file_path: Path to file to upload (optional)
                - file_title: Title for uploaded file (optional)
        
        Returns:
            Dictionary with:
                - success: Boolean indicating if submission was successful
                - tracking_id: Complaint tracking ID if available
                - message: Success/status message
                - error: Error message if failed
                - screenshots: List of screenshot paths
        """
        result = {
            'success': False,
            'tracking_id': None,
            'message': None,
            'error': None,
            'screenshots': [],
            'municipality': 'ranchi',
            'timestamp': datetime.now().isoformat()
        }
        
        try:
            # Validate required fields
            required_fields = ['name', 'phone', 'complaint', 'category']
            missing_fields = [f for f in required_fields if not data.get(f)]
            if missing_fields:
                result['error'] = f"Missing required fields: {', '.join(missing_fields)}"
                logger.error(result['error'])
                return result
            
            # Initialize browser
            await self._init_browser()
            
            # Navigate to form with retry
            nav_success = await self._retry_operation(self._navigate_to_form)
            if not nav_success:
                result['error'] = "Failed to navigate to form"
                return result
            
            # Fill form
            fill_success = await self._fill_form(data)
            if not fill_success:
                result['error'] = "Failed to fill form"
                return result
            
            # Submit form
            submit_result = await self._submit_form()
            result.update(submit_result)
            
            # Add screenshots to result
            result['screenshots'] = self.screenshots.copy()
            
            return result
            
        except Exception as e:
            result['error'] = str(e)
            logger.error(f"Grievance submission failed: {str(e)}")
            if self.page:
                await self._take_screenshot("error_final")
            result['screenshots'] = self.screenshots.copy()
            return result
            
        finally:
            # Cleanup
            await self._cleanup()
    
    async def _cleanup(self):
        """Clean up browser resources."""
        try:
            if self.page:
                await self.page.close()
            if self.context:
                await self.context.close()
            if self.browser:
                await self.browser.close()
            logger.info("Browser resources cleaned up")
        except Exception as e:
            logger.error(f"Error during cleanup: {str(e)}")


async def main():
    """Example usage of the RanchiScraper."""
    # Sample data for testing
    test_data = {
        'name': 'Test User',
        'phone': '9876543210',
        'email': 'test@example.com',
        'complaint': 'This is a test complaint regarding water supply issue in the area.',
        'category': 'Water Supply',
        'area': 'Ward 1',
        'address': '123 Test Street, Ranchi',
        'contact_person_name': 'Test Contact',
        'contact_person_no': '9876543210',
        # 'file_path': '/path/to/document.pdf'  # Optional
    }
    
    # Initialize scraper (headless=False for debugging)
    scraper = RanchiScraper(headless=False, screenshot_dir="./ranchi_screenshots")
    
    # Submit grievance
    result = await scraper.submit_grievance(test_data)
    
    # Print result
    print("\n" + "="*50)
    print("SUBMISSION RESULT")
    print("="*50)
    print(f"Success: {result['success']}")
    print(f"Tracking ID: {result['tracking_id']}")
    print(f"Message: {result['message']}")
    print(f"Error: {result['error']}")
    print(f"Screenshots: {result['screenshots']}")
    print(f"Timestamp: {result['timestamp']}")
    print("="*50)
    
    return result


if __name__ == "__main__":
    asyncio.run(main())