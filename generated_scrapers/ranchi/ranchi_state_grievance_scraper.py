"""
Auto-generated scraper for Ranchi - state_grievance
URL: https://jharkhandegovernance.com/grievance/main
Generated: N/A

This scraper was automatically generated by AI based on website analysis.
It may require adjustments if the website structure changes.

Analysis Summary:
{
  "municipality": "ranchi_state_grievance",
  "page_title": "Grievance",
  "final_url": "https://jharkhandegovernance.com/grievance/main"
}
"""

import asyncio
import logging
import os
from datetime import datetime
from typing import Optional
from playwright.async_api import async_playwright, Page, Browser, BrowserContext, TimeoutError as PlaywrightTimeoutError

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class RanchiScraper:
    """Production-ready Playwright scraper for Ranchi grievance form submission."""
    
    def __init__(self, headless: bool = False, screenshot_dir: str = "screenshots"):
        """
        Initialize the scraper.
        
        Args:
            headless: Run browser in headless mode (False for debugging)
            screenshot_dir: Directory to save screenshots
        """
        self.headless = headless
        self.screenshot_dir = screenshot_dir
        self.base_url = "https://jharkhandegovernance.com/grievance/main"
        self.browser: Optional[Browser] = None
        self.context: Optional[BrowserContext] = None
        self.page: Optional[Page] = None
        self.screenshots: list = []
        
        # Create screenshot directory if it doesn't exist
        os.makedirs(self.screenshot_dir, exist_ok=True)
    
    async def _setup_browser(self):
        """Setup browser with stealth mode configurations."""
        playwright = await async_playwright().start()
        
        # Launch browser with stealth configurations
        self.browser = await playwright.chromium.launch(
            headless=self.headless,
            args=[
                '--disable-blink-features=AutomationControlled',
                '--disable-dev-shm-usage',
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-web-security',
                '--disable-features=IsolateOrigins,site-per-process'
            ]
        )
        
        # Create context with stealth settings
        self.context = await self.browser.new_context(
            viewport={'width': 1920, 'height': 1080},
            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            locale='en-US',
            timezone_id='Asia/Kolkata',
            permissions=['geolocation'],
            java_script_enabled=True,
            bypass_csp=True
        )
        
        # Add stealth scripts
        await self.context.add_init_script("""
            // Override webdriver property
            Object.defineProperty(navigator, 'webdriver', {
                get: () => undefined
            });
            
            // Override plugins
            Object.defineProperty(navigator, 'plugins', {
                get: () => [1, 2, 3, 4, 5]
            });
            
            // Override languages
            Object.defineProperty(navigator, 'languages', {
                get: () => ['en-US', 'en', 'hi']
            });
            
            // Override platform
            Object.defineProperty(navigator, 'platform', {
                get: () => 'Win32'
            });
            
            // Override chrome
            window.chrome = {
                runtime: {}
            };
        """)
        
        self.page = await self.context.new_page()
        
        # Set default timeout
        self.page.set_default_timeout(30000)
        
        logger.info("Browser setup completed with stealth mode")
    
    async def _take_screenshot(self, step_name: str) -> str:
        """Take a screenshot and save it."""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.screenshot_dir}/{step_name}_{timestamp}.png"
        await self.page.screenshot(path=filename, full_page=True)
        self.screenshots.append(filename)
        logger.info(f"Screenshot saved: {filename}")
        return filename
    
    async def _wait_and_click(self, selector: str, timeout: int = 10000):
        """Wait for element and click it."""
        await self.page.wait_for_selector(selector, timeout=timeout)
        await self.page.click(selector)
        logger.info(f"Clicked element: {selector}")
    
    async def _wait_and_fill(self, selector: str, value: str, timeout: int = 10000):
        """Wait for element and fill it."""
        await self.page.wait_for_selector(selector, timeout=timeout)
        await self.page.fill(selector, value)
        logger.info(f"Filled element: {selector}")
    
    async def _select_option(self, selector: str, value: str, timeout: int = 10000):
        """Wait for select element and choose option."""
        await self.page.wait_for_selector(selector, timeout=timeout)
        await self.page.select_option(selector, value)
        logger.info(f"Selected option '{value}' in: {selector}")
    
    async def _navigate_to_form(self) -> bool:
        """Navigate to the grievance registration form."""
        try:
            logger.info(f"Navigating to: {self.base_url}")
            await self.page.goto(self.base_url, wait_until='networkidle')
            await self._take_screenshot("01_initial_page")
            
            # Wait for page to fully load
            await self.page.wait_for_load_state('domcontentloaded')
            await asyncio.sleep(2)  # Additional wait for dynamic content
            
            # Set language to English if language selector exists
            try:
                language_selector = await self.page.query_selector('select')
                if language_selector:
                    await self.page.select_option('select', 'english')
                    logger.info("Language set to English")
                    await asyncio.sleep(1)
            except Exception as e:
                logger.warning(f"Language selector not found or error: {e}")
            
            # Look for grievance registration button/link
            registration_selectors = [
                "text=Register Grievance Now",
                "text=Register Grievance",
                "text=Grievance Registration",
                "a:has-text('Register')",
                "button:has-text('Register')",
                "[href*='register']",
                "[href*='grievance']",
                ".register-btn",
                "#register-grievance"
            ]
            
            for selector in registration_selectors:
                try:
                    element = await self.page.query_selector(selector)
                    if element:
                        await element.click()
                        logger.info(f"Clicked registration button: {selector}")
                        await self.page.wait_for_load_state('networkidle')
                        await asyncio.sleep(2)
                        await self._take_screenshot("02_registration_form")
                        return True
                except Exception as e:
                    logger.debug(f"Selector {selector} not found: {e}")
                    continue
            
            # If no button found, we might already be on the form page
            logger.info("No registration button found, checking if already on form page")
            await self._take_screenshot("02_current_page")
            return True
            
        except Exception as e:
            logger.error(f"Navigation error: {e}")
            await self._take_screenshot("error_navigation")
            return False
    
    async def _fill_form(self, data: dict) -> bool:
        """Fill the grievance form with provided data."""
        try:
            logger.info("Starting form fill process")
            
            # Common field mappings - selectors to try for each field type
            field_mappings = {
                'name': [
                    'input[name*="name"]',
                    'input[id*="name"]',
                    'input[placeholder*="Name"]',
                    'input[placeholder*="name"]',
                    '#name',
                    '#applicant_name',
                    '#complainant_name',
                    'input[type="text"]:first-of-type'
                ],
                'phone': [
                    'input[name*="phone"]',
                    'input[name*="mobile"]',
                    'input[id*="phone"]',
                    'input[id*="mobile"]',
                    'input[placeholder*="Phone"]',
                    'input[placeholder*="Mobile"]',
                    'input[type="tel"]',
                    '#phone',
                    '#mobile'
                ],
                'email': [
                    'input[name*="email"]',
                    'input[id*="email"]',
                    'input[placeholder*="Email"]',
                    'input[type="email"]',
                    '#email'
                ],
                'address': [
                    'textarea[name*="address"]',
                    'input[name*="address"]',
                    'textarea[id*="address"]',
                    'input[id*="address"]',
                    'textarea[placeholder*="Address"]',
                    '#address'
                ],
                'complaint': [
                    'textarea[name*="complaint"]',
                    'textarea[name*="grievance"]',
                    'textarea[name*="description"]',
                    'textarea[name*="details"]',
                    'textarea[id*="complaint"]',
                    'textarea[id*="grievance"]',
                    'textarea[id*="description"]',
                    'textarea[placeholder*="Complaint"]',
                    'textarea[placeholder*="Grievance"]',
                    'textarea[placeholder*="Description"]',
                    '#complaint',
                    '#grievance',
                    '#description',
                    'textarea'
                ],
                'category': [
                    'select[name*="category"]',
                    'select[id*="category"]',
                    'select[name*="type"]',
                    '#category',
                    '#grievance_type',
                    'select:not([name*="language"])'
                ],
                'district': [
                    'select[name*="district"]',
                    'select[id*="district"]',
                    '#district'
                ],
                'municipality': [
                    'select[name*="municipality"]',
                    'select[name*="ulb"]',
                    'select[id*="municipality"]',
                    '#municipality',
                    '#ulb'
                ],
                'ward': [
                    'select[name*="ward"]',
                    'input[name*="ward"]',
                    'select[id*="ward"]',
                    '#ward'
                ]
            }
            
            # Fill each field from data
            for field_name, value in data.items():
                if field_name == 'file_path':
                    continue  # Handle file upload separately
                
                if field_name in field_mappings:
                    selectors = field_mappings[field_name]
                    filled = False
                    
                    for selector in selectors:
                        try:
                            element = await self.page.query_selector(selector)
                            if element:
                                tag_name = await element.evaluate('el => el.tagName.toLowerCase()')
                                
                                if tag_name == 'select':
                                    # Try to select by value or text
                                    try:
                                        await self.page.select_option(selector, value)
                                    except:
                                        await self.page.select_option(selector, label=value)
                                    logger.info(f"Selected {field_name}: {value}")
                                elif tag_name == 'textarea':
                                    await element.fill(value)
                                    logger.info(f"Filled textarea {field_name}")
                                else:
                                    await element.fill(value)
                                    logger.info(f"Filled input {field_name}")
                                
                                filled = True
                                break
                        except Exception as e:
                            logger.debug(f"Could not fill {selector}: {e}")
                            continue
                    
                    if not filled:
                        logger.warning(f"Could not find field for: {field_name}")
            
            await self._take_screenshot("03_form_filled")
            
            # Handle file upload if present
            if 'file_path' in data and data['file_path']:
                await self._handle_file_upload(data['file_path'])
            
            return True
            
        except Exception as e:
            logger.error(f"Form fill error: {e}")
            await self._take_screenshot("error_form_fill")
            return False
    
    async def _handle_file_upload(self, file_path: str) -> bool:
        """Handle file upload if file input exists."""
        try:
            if not os.path.exists(file_path):
                logger.warning(f"File not found: {file_path}")
                return False
            
            file_selectors = [
                'input[type="file"]',
                'input[name*="file"]',
                'input[name*="attachment"]',
                'input[name*="document"]',
                '#file',
                '#attachment',
                '#document'
            ]
            
            for selector in file_selectors:
                try:
                    file_input = await self.page.query_selector(selector)
                    if file_input:
                        await file_input.set_input_files(file_path)
                        logger.info(f"File uploaded: {file_path}")
                        await self._take_screenshot("04_file_uploaded")
                        return True
                except Exception as e:
                    logger.debug(f"File upload selector {selector} failed: {e}")
                    continue
            
            logger.warning("No file input found on the form")
            return False
            
        except Exception as e:
            logger.error(f"File upload error: {e}")
            return False
    
    async def _submit_form(self) -> dict:
        """Submit the form and capture result."""
        result = {
            'success': False,
            'tracking_id': None,
            'message': None
        }
        
        try:
            # Find and click submit button
            submit_selectors = [
                'button[type="submit"]',
                'input[type="submit"]',
                'button:has-text("Submit")',
                'button:has-text("Register")',
                'button:has-text("Register Grievance Now")',
                'button:has-text("Send")',
                '.submit-btn',
                '#submit',
                '#register',
                'button.btn-primary',
                'button.btn-success'
            ]
            
            submitted = False
            for selector in submit_selectors:
                try:
                    element = await self.page.query_selector(selector)
                    if element:
                        # Scroll element into view
                        await element.scroll_into_view_if_needed()
                        await asyncio.sleep(0.5)
                        
                        # Click submit
                        await element.click()
                        logger.info(f"Clicked submit button: {selector}")
                        submitted = True
                        break
                except Exception as e:
                    logger.debug(f"Submit selector {selector} failed: {e}")
                    continue
            
            if not submitted:
                result['message'] = "Could not find submit button"
                logger.error(result['message'])
                await self._take_screenshot("error_no_submit_button")
                return result
            
            # Wait for response
            await asyncio.sleep(3)
            await self.page.wait_for_load_state('networkidle')
            await self._take_screenshot("05_after_submit")
            
            # Check for success message and tracking ID
            success_indicators = [
                'text=successfully',
                'text=Success',
                'text=submitted',
                'text=registered',
                'text=Thank you',
                '.success',
                '.alert-success',
                '#success-message'
            ]
            
            for indicator in success_indicators:
                try:
                    element = await self.page.query_selector(indicator)
                    if element:
                        result['success'] = True
                        result['message'] = await element.text_content()
                        logger.info(f"Success indicator found: {result['message']}")
                        break
                except:
                    continue
            
            # Try to extract tracking ID
            tracking_patterns = [
                r'[A-Z]{2,4}[-/]?\d{6,12}',
                r'GR[-/]?\d+',
                r'REF[-/]?\d+',
                r'ID[-/:]?\s*(\d+)',
                r'Tracking\s*(?:ID|Number|No\.?)[-:/]?\s*([A-Z0-9-]+)'
            ]
            
            page_content = await self.page.content()
            import re
            for pattern in tracking_patterns:
                match = re.search(pattern, page_content, re.IGNORECASE)
                if match:
                    result['tracking_id'] = match.group(0)
                    logger.info(f"Tracking ID found: {result['tracking_id']}")
                    break
            
            # Check for error messages
            if not result['success']:
                error_selectors = [
                    '.error',
                    '.alert-danger',
                    '.alert-error',
                    '#error-message',
                    'text=error',
                    'text=failed',
                    'text=invalid'
                ]
                
                for selector in error_selectors:
                    try:
                        element = await self.page.query_selector(selector)
                        if element:
                            result['message'] = await element.text_content()
                            logger.warning(f"Error message found: {result['message']}")
                            break
                    except:
                        continue
            
            return result
            
        except Exception as e:
            logger.error(f"Form submission error: {e}")
            await self._take_screenshot("error_submission")
            result['message'] = str(e)
            return result
    
    async def submit_grievance(self, data: dict, max_retries: int = 3) -> dict:
        """
        Submit a grievance with the provided data.
        
        Args:
            data: Dictionary containing grievance data
                  {"name": "...", "phone": "...", "complaint": "...", "category": "...", "file_path": "..."}
            max_retries: Maximum number of retry attempts
        
        Returns:
            Dictionary with submission result:
            {
                "success": bool,
                "tracking_id": str or None,
                "screenshots": list of screenshot paths,
                "errors": list of error messages,
                "message": str
            }
        """
        result = {
            'success': False,
            'tracking_id': None,
            'screenshots': [],
            'errors': [],
            'message': None
        }
        
        self.screenshots = []
        
        for attempt in range(max_retries):
            try:
                logger.info(f"Attempt {attempt + 1} of {max_retries}")
                
                # Setup browser
                await self._setup_browser()
                
                # Navigate to form
                if not await self._navigate_to_form():
                    raise Exception("Failed to navigate to grievance form")
                
                # Fill form
                if not await self._fill_form(data):
                    raise Exception("Failed to fill grievance form")
                
                # Submit form
                submit_result = await self._submit_form()
                
                result['success'] = submit_result['success']
                result['tracking_id'] = submit_result['tracking_id']
                result['message'] = submit_result['message']
                result['screenshots'] = self.screenshots.copy()
                
                if result['success']:
                    logger.info("Grievance submitted successfully")
                    break
                else:
                    error_msg = f"Attempt {attempt + 1} failed: {submit_result['message']}"
                    result['errors'].append(error_msg)
                    logger.warning(error_msg)
                    
            except PlaywrightTimeoutError as e:
                error_msg = f"Timeout error on attempt {attempt + 1}: {str(e)}"
                result['errors'].append(error_msg)
                logger.error(error_msg)
                await self._take_screenshot(f"error_timeout_attempt_{attempt + 1}")
                
            except Exception as e:
                error_msg = f"Error on attempt {attempt + 1}: {str(e)}"
                result['errors'].append(error_msg)
                logger.error(error_msg)
                try:
                    await self._take_screenshot(f"error_attempt_{attempt + 1}")
                except:
                    pass
                    
            finally:
                # Cleanup
                await self._cleanup()
                
                if not result['success'] and attempt < max_retries - 1:
                    logger.info(f"Waiting before retry...")
                    await asyncio.sleep(5)
        
        result['screenshots'] = self.screenshots
        return result
    
    async def _cleanup(self):
        """Clean up browser resources."""
        try:
            if self.page:
                await self.page.close()
            if self.context:
                await self.context.close()
            if self.browser:
                await self.browser.close()
            logger.info("Browser cleanup completed")
        except Exception as e:
            logger.error(f"Cleanup error: {e}")


async def main():
    """Example usage of the RanchiScraper."""
    # Sample grievance data
    grievance_data = {
        'name': 'Test User',
        'phone': '9876543210',
        'email': 'test@example.com',
        'address': '123 Test Street, Ranchi, Jharkhand',
        'complaint': 'This is a test grievance submission for water supply issue in Ward 15. The water supply has been irregular for the past week.',
        'category': 'Water Supply',
        'district': 'Ranchi',
        'municipality': 'Ranchi',
        'ward': '15',
        # 'file_path': '/path/to/document.pdf'  # Optional file attachment
    }
    
    # Initialize scraper (headless=False for debugging)
    scraper = RanchiScraper(headless=False, screenshot_dir="grievance_screenshots")
    
    # Submit grievance
    result = await scraper.submit_grievance(grievance_data)
    
    # Print result
    print("\n" + "="*50)
    print("GRIEVANCE SUBMISSION RESULT")
    print("="*50)
    print(f"Success: {result['success']}")
    print(f"Tracking ID: {result['tracking_id']}")
    print(f"Message: {result['message']}")
    print(f"Screenshots: {result['screenshots']}")
    if result['errors']:
        print(f"Errors: {result['errors']}")
    print("="*50)
    
    return result


if __name__ == "__main__":
    asyncio.run(main())