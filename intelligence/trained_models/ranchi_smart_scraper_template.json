{
  "municipality": "ranchi_smart",
  "scraper_template": {
    "scraper_template": {},
    "raw_response": "```json\n{\n  \"scraper_template\": {\n    \"class_name\": \"RanchiSmartScraper\",\n    \"imports\": [\n      \"import asyncio\",\n      \"import logging\",\n      \"import re\",\n      \"from pathlib import Path\",\n      \"from typing import Dict, Any, Optional, List, Tuple\",\n      \"from datetime import datetime\",\n      \"from playwright.async_api import async_playwright, Browser, Page, BrowserContext, ElementHandle, TimeoutError as PlaywrightTimeout\"\n    ],\n    \"class_structure\": \"\\\"\\\"\\\"\\\\nProduction-ready scraper for Ranchi Smart City grievance portal\\\\nMunicipality: ranchi_smart\\\\nURL: https://smartranchi.in/Portal/View/ComplaintRegistration.aspx?m=Online\\\\n\\\\nFeatures:\\\\n- ASP.NET WebForms handling (ViewState, EventValidation, __doPostBack)\\\\n- Cascading dropdown support\\\\n- Robust error handling and retry logic\\\\n- Comprehensive logging\\\\n- Screenshot capture for debugging\\\\n\\\"\\\"\\\"\\\\n\\\\nimport asyncio\\\\nimport logging\\\\nimport re\\\\nfrom pathlib import Path\\\\nfrom typing import Dict, Any, Optional, List, Tuple\\\\nfrom datetime import datetime\\\\nfrom playwright.async_api import (\\\\n    async_playwright,\\\\n    Browser,\\\\n    Page,\\\\n    BrowserContext,\\\\n    ElementHandle,\\\\n    TimeoutError as PlaywrightTimeout\\\\n)\\\\n\\\\nlogging.basicConfig(\\\\n    level=logging.INFO,\\\\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\\\\n)\\\\nlogger = logging.getLogger(__name__)\\\\n\\\\n\\\\nclass RanchiSmartScraper:\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    Production scraper for Ranchi Smart City grievance submission portal.\\\\n    \\\\n    Handles ASP.NET WebForms with:\\\\n    - ViewState and EventValidation preservation\\\\n    - Cascading dropdowns with postback triggers\\\\n    - Dynamic field validation\\\\n    - Success/error message detection\\\\n    \\\\\\\"\\\\\\\"\\\\\\\"\\\\n    \\\\n    # ASP.NET ContentPlaceHolder prefix\\\\n    CONTENT_PREFIX = \\\\\\\"#ContentPlaceHolder1_\\\\\\\"\\\\n    \\\\n    # Field mappings: grievance_data key -> form field ID\\\\n    FIELD_MAPPINGS = {\\\\n        \\\\\\\"problem_type\\\\\\\": \\\\\\\"ddlProblemType\\\\\\\",\\\\n        \\\\\\\"problem\\\\\\\": \\\\\\\"ddlProblem\\\\\\\",\\\\n        \\\\\\\"mobile\\\\\\\": \\\\\\\"txtMobileNo\\\\\\\",\\\\n        \\\\\\\"name\\\\\\\": \\\\\\\"txtName\\\\\\\",\\\\n        \\\\\\\"email\\\\\\\": \\\\\\\"txtEmail\\\\\\\",\\\\n        \\\\\\\"address\\\\\\\": \\\\\\\"txtAddress\\\\\\\",\\\\n        \\\\\\\"landmark\\\\\\\": \\\\\\\"txtLandmark\\\\\\\",\\\\n        \\\\\\\"description\\\\\\\": \\\\\\\"txtDescription\\\\\\\",\\\\n        \\\\\\\"remarks\\\\\\\": \\\\\\\"txtRemarks\\\\\\\",\\\\n        \\\\\\\"ward\\\\\\\": \\\\\\\"ddlWard\\\\\\\",\\\\n        \\\\\\\"locality\\\\\\\": \\\\\\\"ddlLocality\\\\\\\",\\\\n    }\\\\n    \\\\n    # Dropdown fields that trigger postback\\\\n    POSTBACK_DROPDOWNS = [\\\\\\\"ddlProblemType\\\\\\\", \\\\\\\"ddlWard\\\\\\\"]\\\\n    \\\\n    # Success message patterns\\\\n    SUCCESS_PATTERNS = [\\\\n        r\\\\\\\"complaint.*registered.*successfully\\\\\\\",\\\\n        r\\\\\\\"tracking.*id[:\\\\\\\\s]*([A-Z0-9-]+)\\\\\\\",\\\\n        r\\\\\\\"reference.*number[:\\\\\\\\s]*([A-Z0-9-]+)\\\\\\\",\\\\n        r\\\\\\\"complaint.*number[:\\\\\\\\s]*([A-Z0-9-]+)\\\\\\\",\\\\n        r\\\\\\\"successfully.*submitted\\\\\\\",\\\\n    ]\\\\n    \\\\n    # Error message patterns\\\\n    ERROR_PATTERNS = [\\\\n        r\\\\\\\"required.*field\\\\\\\",\\\\n        r\\\\\\\"invalid.*input\\\\\\\",\\\\n        r\\\\\\\"please.*select\\\\\\\",\\\\n        r\\\\\\\"please.*enter\\\\\\\",\\\\n        r\\\\\\\"validation.*failed\\\\\\\",\\\\n    ]\\\\n\\\\n    def __init__(\\\\n        self,\\\\n        headless: bool = True,\\\\n        timeout: int = 30000,\\\\n        screenshot_dir: Optional[str] = None,\\\\n        max_retries: int = 3,\\\\n        retry_delay: float = 2.0\\\\n    ):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Initialize the scraper.\\\\n        \\\\n        Args:\\\\n            headless: Run browser in headless mode\\\\n            timeout: Default timeout for operations in milliseconds\\\\n            screenshot_dir: Directory to save debug screenshots\\\\n            max_retries: Maximum retry attempts for failed operations\\\\n            retry_delay: Delay between retries in seconds\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        self.base_url = \\\\\\\"https://smartranchi.in/Portal/View/ComplaintRegistration.aspx?m=Online\\\\\\\"\\\\n        self.headless = headless\\\\n        self.timeout = timeout\\\\n        self.max_retries = max_retries\\\\n        self.retry_delay = retry_delay\\\\n        \\\\n        self.screenshot_dir = Path(screenshot_dir) if screenshot_dir else Path(\\\\\\\"./screenshots\\\\\\\")\\\\n        self.screenshot_dir.mkdir(parents=True, exist_ok=True)\\\\n        \\\\n        self._browser: Optional[Browser] = None\\\\n        self._context: Optional[BrowserContext] = None\\\\n        self._page: Optional[Page] = None\\\\n        self._playwright = None\\\\n\\\\n    async def __aenter__(self):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Async context manager entry.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        await self._init_browser()\\\\n        return self\\\\n\\\\n    async def __aexit__(self, exc_type, exc_val, exc_tb):\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Async context manager exit.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        await self._cleanup()\\\\n\\\\n    async def _init_browser(self) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Initialize browser instance.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.info(\\\\\\\"\ud83d\ude80 Initializing browser...\\\\\\\")\\\\n        self._playwright = await async_playwright().start()\\\\n        self._browser = await self._playwright.chromium.launch(\\\\n            headless=self.headless,\\\\n            args=[\\\\n                '--disable-blink-features=AutomationControlled',\\\\n                '--no-sandbox',\\\\n                '--disable-dev-shm-usage'\\\\n            ]\\\\n        )\\\\n        self._context = await self._browser.new_context(\\\\n            viewport={'width': 1920, 'height': 1080},\\\\n            user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\\\\n        )\\\\n        self._page = await self._context.new_page()\\\\n        self._page.set_default_timeout(self.timeout)\\\\n        logger.info(\\\\\\\"\u2705 Browser initialized\\\\\\\")\\\\n\\\\n    async def _cleanup(self) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"Clean up browser resources.\\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.info(\\\\\\\"\ud83e\uddf9 Cleaning up browser resources...\\\\\\\")\\\\n        try:\\\\n            if self._page:\\\\n                await self._page.close()\\\\n            if self._context:\\\\n                await self._context.close()\\\\n            if self._browser:\\\\n                await self._browser.close()\\\\n            if self._playwright:\\\\n                await self._playwright.stop()\\\\n        except Exception as e:\\\\n            logger.warning(f\\\\\\\"Cleanup warning: {e}\\\\\\\")\\\\n        finally:\\\\n            self._page = None\\\\n            self._context = None\\\\n            self._browser = None\\\\n            self._playwright = None\\\\n\\\\n    async def _take_screenshot(self, name: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Take a debug screenshot.\\\\n        \\\\n        Args:\\\\n            name: Screenshot identifier\\\\n            \\\\n        Returns:\\\\n            Path to saved screenshot\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        timestamp = datetime.now().strftime(\\\\\\\"%Y%m%d_%H%M%S\\\\\\\")\\\\n        filename = f\\\\\\\"{name}_{timestamp}.png\\\\\\\"\\\\n        filepath = self.screenshot_dir / filename\\\\n        await self._page.screenshot(path=str(filepath), full_page=True)\\\\n        logger.debug(f\\\\\\\"\ud83d\udcf8 Screenshot saved: {filepath}\\\\\\\")\\\\n        return str(filepath)\\\\n\\\\n    def _get_selector(self, field_id: str) -> str:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Get full CSS selector for ASP.NET field.\\\\n        \\\\n        Args:\\\\n            field_id: Short field ID (without ContentPlaceHolder prefix)\\\\n            \\\\n        Returns:\\\\n            Full CSS selector\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return f\\\\\\\"{self.CONTENT_PREFIX}{field_id}\\\\\\\"\\\\n\\\\n    async def _wait_for_postback(self, timeout: int = 5000) -> None:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Wait for ASP.NET postback to complete.\\\\n        \\\\n        Args:\\\\n            timeout: Maximum wait time in milliseconds\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            # Wait for network to be idle\\\\n            await self._page.wait_for_load_state(\\\\\\\"networkidle\\\\\\\", timeout=timeout)\\\\n            # Additional delay for ASP.NET processing\\\\n            await asyncio.sleep(0.5)\\\\n        except PlaywrightTimeout:\\\\n            logger.debug(\\\\\\\"Postback wait timed out, continuing...\\\\\\\")\\\\n\\\\n    async def _fill_text_field(\\\\n        self,\\\\n        field_id: str,\\\\n        value: str,\\\\n        clear_first: bool = True\\\\n    ) -> bool:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Fill a text input field.\\\\n        \\\\n        Args:\\\\n            field_id: Field ID (without prefix)\\\\n            value: Value to enter\\\\n            clear_first: Whether to clear existing value\\\\n            \\\\n        Returns:\\\\n            True if successful\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        selector = self._get_selector(field_id)\\\\n        try:\\\\n            element = await self._page.wait_for_selector(selector, state=\\\\\\\"visible\\\\\\\", timeout=5000)\\\\n            if not element:\\\\n                logger.warning(f\\\\\\\"Field not found: {field_id}\\\\\\\")\\\\n                return False\\\\n            \\\\n            if clear_first:\\\\n                await element.click()\\\\n                await self._page.keyboard.press(\\\\\\\"Control+a\\\\\\\")\\\\n                await self._page.keyboard.press(\\\\\\\"Delete\\\\\\\")\\\\n            \\\\n            await element.fill(str(value))\\\\n            logger.info(f\\\\\\\"\u270f\ufe0f Filled {field_id}: {value[:50]}{'...' if len(str(value)) > 50 else ''}\\\\\\\")\\\\n            return True\\\\n            \\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Failed to fill {field_id}: {e}\\\\\\\")\\\\n            return False\\\\n\\\\n    async def _select_dropdown(\\\\n        self,\\\\n        field_id: str,\\\\n        value: str,\\\\n        wait_for_postback: bool = False\\\\n    ) -> bool:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Select a dropdown option.\\\\n        \\\\n        Handles both standard HTML selects and ASP.NET dropdowns.\\\\n        \\\\n        Args:\\\\n            field_id: Field ID (without prefix)\\\\n            value: Value or label to select\\\\n            wait_for_postback: Whether to wait for postback after selection\\\\n            \\\\n        Returns:\\\\n            True if successful\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        selector = self._get_selector(field_id)\\\\n        try:\\\\n            element = await self._page.wait_for_selector(selector, state=\\\\\\\"visible\\\\\\\", timeout=5000)\\\\n            if not element:\\\\n                logger.warning(f\\\\\\\"Dropdown not found: {field_id}\\\\\\\")\\\\n                return False\\\\n            \\\\n            # Try selecting by value first, then by label\\\\n            try:\\\\n                await self._page.select_option(selector, value=value)\\\\n            except Exception:\\\\n                await self._page.select_option(selector, label=value)\\\\n            \\\\n            logger.info(f\\\\\\\"\ud83d\udccb Selected {field_id}: {value}\\\\\\\")\\\\n            \\\\n            # Handle postback for cascading dropdowns\\\\n            if wait_for_postback or field_id in self.POSTBACK_DROPDOWNS:\\\\n                logger.debug(f\\\\\\\"Waiting for postback after {field_id} selection...\\\\\\\")\\\\n                await self._wait_for_postback()\\\\n            \\\\n            return True\\\\n            \\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Failed to select {field_id}: {e}\\\\\\\")\\\\n            return False\\\\n\\\\n    async def _select_dropdown_by_index(\\\\n        self,\\\\n        field_id: str,\\\\n        index: int,\\\\n        wait_for_postback: bool = False\\\\n    ) -> bool:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Select dropdown option by index.\\\\n        \\\\n        Args:\\\\n            field_id: Field ID (without prefix)\\\\n            index: Option index (0-based)\\\\n            wait_for_postback: Whether to wait for postback\\\\n            \\\\n        Returns:\\\\n            True if successful\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        selector = self._get_selector(field_id)\\\\n        try:\\\\n            await self._page.select_option(selector, index=index)\\\\n            logger.info(f\\\\\\\"\ud83d\udccb Selected {field_id} by index: {index}\\\\\\\")\\\\n            \\\\n            if wait_for_postback or field_id in self.POSTBACK_DROPDOWNS:\\\\n                await self._wait_for_postback()\\\\n            \\\\n            return True\\\\n            \\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Failed to select {field_id} by index: {e}\\\\\\\")\\\\n            return False\\\\n\\\\n    async def _get_dropdown_options(self, field_id: str) -> List[Dict[str, str]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Get all options from a dropdown.\\\\n        \\\\n        Args:\\\\n            field_id: Field ID (without prefix)\\\\n            \\\\n        Returns:\\\\n            List of option dictionaries with 'value' and 'label' keys\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        selector = self._get_selector(field_id)\\\\n        try:\\\\n            options = await self._page.eval_on_selector(\\\\n                selector,\\\\n                \\\\\\\"\\\\\\\"\\\\\\\"el => Array.from(el.options).map(o => ({\\\\n                    value: o.value,\\\\n                    label: o.text.trim()\\\\n                }))\\\\\\\"\\\\\\\"\\\\\\\"\\\\n            )\\\\n            return options\\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Failed to get options for {field_id}: {e}\\\\\\\")\\\\n            return []\\\\n\\\\n    async def _fill_textarea(self, field_id: str, value: str) -> bool:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Fill a textarea field.\\\\n        \\\\n        Args:\\\\n            field_id: Field ID (without prefix)\\\\n            value: Text content\\\\n            \\\\n        Returns:\\\\n            True if successful\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        return await self._fill_text_field(field_id, value)\\\\n\\\\n    async def _upload_file(self, field_id: str, file_path: str) -> bool:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Upload a file to a file input.\\\\n        \\\\n        Args:\\\\n            field_id: Field ID (without prefix)\\\\n            file_path: Path to file to upload\\\\n            \\\\n        Returns:\\\\n            True if successful\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        selector = self._get_selector(field_id)\\\\n        try:\\\\n            file_input = await self._page.wait_for_selector(selector, timeout=5000)\\\\n            if not file_input:\\\\n                logger.warning(f\\\\\\\"File input not found: {field_id}\\\\\\\")\\\\n                return False\\\\n            \\\\n            await file_input.set_input_files(file_path)\\\\n            logger.info(f\\\\\\\"\ud83d\udcce Uploaded file to {field_id}: {file_path}\\\\\\\")\\\\n            return True\\\\n            \\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Failed to upload file to {field_id}: {e}\\\\\\\")\\\\n            return False\\\\n\\\\n    async def _click_button(self, field_id: str) -> bool:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Click a button element.\\\\n        \\\\n        Args:\\\\n            field_id: Button ID (without prefix)\\\\n            \\\\n        Returns:\\\\n            True if successful\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        selector = self._get_selector(field_id)\\\\n        try:\\\\n            button = await self._page.wait_for_selector(selector, state=\\\\\\\"visible\\\\\\\", timeout=5000)\\\\n            if not button:\\\\n                logger.warning(f\\\\\\\"Button not found: {field_id}\\\\\\\")\\\\n                return False\\\\n            \\\\n            await button.click()\\\\n            logger.info(f\\\\\\\"\ud83d\uddb1\ufe0f Clicked button: {field_id}\\\\\\\")\\\\n            return True\\\\n            \\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Failed to click {field_id}: {e}\\\\\\\")\\\\n            return False\\\\n\\\\n    async def _extract_tracking_id(self) -> Optional[str]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Extract tracking/reference ID from success page.\\\\n        \\\\n        Returns:\\\\n            Tracking ID if found, None otherwise\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            page_content = await self._page.content()\\\\n            page_text = await self._page.inner_text(\\\\\\\"body\\\\\\\")\\\\n            \\\\n            # Try each success pattern\\\\n            for pattern in self.SUCCESS_PATTERNS:\\\\n                match = re.search(pattern, page_text, re.IGNORECASE)\\\\n                if match:\\\\n                    # If pattern has capture group, return it\\\\n                    if match.groups():\\\\n                        tracking_id = match.group(1)\\\\n                        logger.info(f\\\\\\\"\ud83c\udfab Found tracking ID: {tracking_id}\\\\\\\")\\\\n                        return tracking_id\\\\n            \\\\n            # Try common ID element selectors\\\\n            id_selectors = [\\\\n                \\\\\\\"#ContentPlaceHolder1_lblComplaintNo\\\\\\\",\\\\n                \\\\\\\"#ContentPlaceHolder1_lblTrackingId\\\\\\\",\\\\n                \\\\\\\"#ContentPlaceHolder1_lblReferenceNo\\\\\\\",\\\\n                \\\\\\\".tracking-id\\\\\\\",\\\\n                \\\\\\\".complaint-number\\\\\\\",\\\\n                \\\\\\\"[id*='ComplaintNo']\\\\\\\",\\\\n                \\\\\\\"[id*='TrackingId']\\\\\\\",\\\\n            ]\\\\n            \\\\n            for selector in id_selectors:\\\\n                try:\\\\n                    element = await self._page.query_selector(selector)\\\\n                    if element:\\\\n                        text = await element.inner_text()\\\\n                        if text and text.strip():\\\\n                            tracking_id = text.strip()\\\\n                            logger.info(f\\\\\\\"\ud83c\udfab Found tracking ID from element: {tracking_id}\\\\\\\")\\\\n                            return tracking_id\\\\n                except Exception:\\\\n                    continue\\\\n            \\\\n            return None\\\\n            \\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Error extracting tracking ID: {e}\\\\\\\")\\\\n            return None\\\\n\\\\n    async def _check_for_errors(self) -> List[str]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Check for validation or error messages on page.\\\\n        \\\\n        Returns:\\\\n            List of error messages found\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        errors = []\\\\n        try:\\\\n            # Check common error element selectors\\\\n            error_selectors = [\\\\n                \\\\\\\".error-message\\\\\\\",\\\\n                \\\\\\\".validation-error\\\\\\\",\\\\n                \\\\\\\".field-validation-error\\\\\\\",\\\\n                \\\\\\\"[id*='ValidationSummary']\\\\\\\",\\\\n                \\\\\\\".alert-danger\\\\\\\",\\\\n                \\\\\\\"span[style*='color:red']\\\\\\\",\\\\n                \\\\\\\"span[style*='color: red']\\\\\\\",\\\\n            ]\\\\n            \\\\n            for selector in error_selectors:\\\\n                elements = await self._page.query_selector_all(selector)\\\\n                for element in elements:\\\\n                    text = await element.inner_text()\\\\n                    if text and text.strip():\\\\n                        errors.append(text.strip())\\\\n            \\\\n            # Check page text for error patterns\\\\n            page_text = await self._page.inner_text(\\\\\\\"body\\\\\\\")\\\\n            for pattern in self.ERROR_PATTERNS:\\\\n                if re.search(pattern, page_text, re.IGNORECASE):\\\\n                    match = re.search(f\\\\\\\"({pattern}[^.]*)\\\\\\\", page_text, re.IGNORECASE)\\\\n                    if match and match.group(1) not in errors:\\\\n                        errors.append(match.group(1))\\\\n            \\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Error checking for errors: {e}\\\\\\\")\\\\n        \\\\n        return errors\\\\n\\\\n    async def _is_submission_successful(self) -> Tuple[bool, Optional[str]]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Check if form submission was successful.\\\\n        \\\\n        Returns:\\\\n            Tuple of (success_status, tracking_id)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        try:\\\\n            page_text = await self._page.inner_text(\\\\\\\"body\\\\\\\")\\\\n            \\\\n            # Check for success indicators\\\\n            success_indicators = [\\\\n                \\\\\\\"successfully\\\\\\\",\\\\n                \\\\\\\"complaint registered\\\\\\\",\\\\n                \\\\\\\"thank you\\\\\\\",\\\\n                \\\\\\\"submission complete\\\\\\\",\\\\n            ]\\\\n            \\\\n            for indicator in success_indicators:\\\\n                if indicator.lower() in page_text.lower():\\\\n                    tracking_id = await self._extract_tracking_id()\\\\n                    return True, tracking_id\\\\n            \\\\n            # Check for error indicators\\\\n            errors = await self._check_for_errors()\\\\n            if errors:\\\\n                logger.warning(f\\\\\\\"Found errors: {errors}\\\\\\\")\\\\n                return False, None\\\\n            \\\\n            return False, None\\\\n            \\\\n        except Exception as e:\\\\n            logger.error(f\\\\\\\"Error checking submission status: {e}\\\\\\\")\\\\n            return False, None\\\\n\\\\n    async def _fill_form(self, grievance_data: Dict[str, Any]) -> bool:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Fill the grievance form with provided data.\\\\n        \\\\n        Args:\\\\n            grievance_data: Dictionary with field values\\\\n            \\\\n        Returns:\\\\n            True if form filled successfully\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        logger.info(\\\\\\\"\ud83d\udcdd Filling grievance form...\\\\\\\")\\\\n        \\\\n        # Define field filling order (important for cascading dropdowns)\\\\n        field_order = [\\\\n            \\\\\\\"problem_type\\\\\\\",  # Must be first - triggers postback\\\\n            \\\\\\\"problem\\\\\\\",       # Depends on problem_type\\\\n            \\\\\\\"ward\\\\\\\",          # May trigger postback\\\\n            \\\\\\\"locality\\\\\\\",      # May depend on ward\\\\n            \\\\\\\"mobile\\\\\\\",\\\\n            \\\\\\\"name\\\\\\\",\\\\n            \\\\\\\"email\\\\\\\",\\\\n            \\\\\\\"address\\\\\\\",\\\\n            \\\\\\\"landmark\\\\\\\",\\\\n            \\\\\\\"description\\\\\\\",\\\\n            \\\\\\\"remarks\\\\\\\",\\\\n        ]\\\\n        \\\\n        for field_key in field_order:\\\\n            if field_key not in grievance_data:\\\\n                continue\\\\n            \\\\n            value = grievance_data[field_key]\\\\n            if not value:\\\\n                continue\\\\n            \\\\n            field_id = self.FIELD_MAPPINGS.get(field_key)\\\\n            if not field_id:\\\\n                logger.warning(f\\\\\\\"Unknown field: {field_key}\\\\\\\")\\\\n                continue\\\\n            \\\\n            # Determine field type and fill accordingly\\\\n            if field_id.startswith(\\\\\\\"ddl\\\\\\\"):\\\\n                # Dropdown field\\\\n                wait_postback = field_id in self.POSTBACK_DROPDOWNS\\\\n                success = await self._select_dropdown(field_id, value, wait_postback)\\\\n            elif field_id.startswith(\\\\\\\"txt\\\\\\\"):\\\\n                # Text field\\\\n                success = await self._fill_text_field(field_id, value)\\\\n            else:\\\\n                # Generic fill\\\\n                success = await self._fill_text_field(field_id, value)\\\\n            \\\\n            if not success:\\\\n                logger.warning(f\\\\\\\"Failed to fill field: {field_key}\\\\\\\")\\\\n        \\\\n        # Handle any additional fields not in standard mapping\\\\n        for key, value in grievance_data.items():\\\\n            if key not in self.FIELD_MAPPINGS and key not in field_order:\\\\n                logger.debug(f\\\\\\\"Skipping unmapped field: {key}\\\\\\\")\\\\n        \\\\n        return True\\\\n\\\\n    async def submit_grievance(self, grievance_data: Dict[str, Any]) -> Dict[str, Any]:\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        Submit a grievance to the portal.\\\\n        \\\\n        Args:\\\\n            grievance_data: Dictionary containing:\\\\n                - problem_type: Type of problem (dropdown value)\\\\n                - problem: Specific problem (dropdown value)\\\\n                - mobile: Mobile number (required)\\\\n                - name: Complainant name\\\\n                - email: Email address\\\\n                - address: Full address\\\\n                - landmark: Nearby landmark\\\\n                - description: Problem description\\\\n                - remarks: Additional remarks\\\\n                - ward: Ward selection\\\\n                - locality: Locality selection\\\\n                - file_path: Optional file attachment path\\\\n        \\\\n        Returns:\\\\n            Result dictionary with:\\\\n                - success: bool\\\\n                - tracking_id: str or None\\\\n                - message: str\\\\n                - errors: list\\\\n                - screenshot: str (path to screenshot)\\\\n        \\\\\\\"\\\\\\\"\\\\\\\"\\\\n        result = {\\\\n            \\\\\\\"success\\\\\\\": False,\\\\n            \\\\\\\"tracking_id\\\\\\\": None,\\\\n            \\\\\\\"message\\\\\\\": \\\\\\\"\\\\\\\",\\\\n            \\\\\\\"errors\\\\\\\": [],\\\\n            \\\\\\\"screenshot\\\\\\\": None,\\\\n            \\\\\\\"timestamp\\\\\\\": datetime.now().isoformat()\\\\n        }\\\\n        \\\\n        # Initialize browser if not already done\\\\n        if not self._browser:\\\\n            await self._init_browser()\\\\n        \\\\n        for attempt in range(self.max_retries + 1):\\\\n            try:\\\\n                logger.info(f\\\\\\\"\ud83d\ude80 Submission attempt {attempt + 1}/{self.max_retries + 1}\\\\\\\")\\\\n                \\\\n                # Navigate to form\\\\n                logger.info(f\\\\\\\"\ud83d\udccd Navigating to {self.base_url}\\\\\\\")\\\\n                await self._page.goto(self.base_url, wait_until=\\\\\\\"networkidle\\\\\\\", timeout=self.timeout)\\\\n                await asyncio.sleep(2)  # Allow page to fully load\\\\n                \\\\n                # Take initial screenshot\\\\n                await self._take_screenshot(\\\\\\\"01_initial_page\\\\\\\")\\\\n                \\\\n                # Fill the form\\\\n                await self._fill_form(grievance_data)\\\\n                \\\\n                # Handle file upload if provided\\\\n                if \\\\\\\"file_path\\\\\\\" in grievance_data and grievance_data[\\\\\\\"file_path\\\\\\\"]:\\\\n                    await self._upload_file(\\\\\\\"fileUpload\\\\\\\", grievance_data[\\\\\\\"file_path\\\\\\\"])\\\\n                \\\\n                # Take pre-submit screenshot\\\\n                await self._take_screenshot(\\\\\\\"02_form_filled\\\\\\\")\\\\n                \\\\n                # Submit the form\\\\n                logger.info(\\\\\\\"\ud83d\udce4 Submitting form...\\\\\\\")\\\\n                submit_success = await self._click_button(\\\\\\\"btnSubmit\\\\\\\")\\\\n                \\\\n                if not submit_success:\\\\n                    # Try alternative submit button selectors\\\\n                    alt_selectors = [\\\\\\\"btnSave\\\\\\\", \\\\\\\"btnRegister\\\\\\\", \\\\\\\"Button1\\\\\\\"]\\\\n                    for alt in alt_selectors:\\\\n                        if await self._click_button(alt):\\\\n                            submit_success = True\\\\n                            break\\\\n                \\\\n                if not submit_success:\\\\n                    raise Exception(\\\\\\\"Could not find submit button\\\\\\\")\\\\n                \\\\n                # Wait for submission to process\\\\n                await self._wait_for_postback(timeout=15000)\\\\n                await asyncio.sleep(2)\\\\n                \\\\n                # Take post-submit screenshot\\\\n                result[\\\\\\\"screenshot\\\\\\\"] = await self._take_screenshot(\\\\\\\"03_after_submit\\\\\\\")\\\\n                \\\\n                # Check submission result\\\\n                success, tracking_id = await self._is_submission_successful()\\\\n                errors = await self._check_for_errors()\\\\n                \\\\n                if success:\\\\n                    result[\\\\\\\"success\\\\\\\"] = True\\\\n                    result[\\\\\\\"tracking_id\\\\\\\"] = tracking_id\\\\n                    result[\\\\\\\"message\\\\\\\"] = \\\\\\\"Grievance submitted successfully\\\\\\\"\\\\n                    logger.info(f\\\\\\\"\u2705 Submission successful! Tracking ID: {tracking_id}\\\\\\\")\\\\n                    return result\\\\n                elif errors:\\\\n                    result[\\\\\\\"errors\\\\\\\"] = errors\\\\n                    result[\\\\\\\"message\\\\\\\"] = f\\\\\\\"Validation errors: {'; '.join(errors)}\\\\\\\"\\\\n                    logger.warning(f\\\\\\\"\u274c Submission failed with errors: {errors}\\\\\\\")\\\\n                    # Don't retry on validation errors\\\\n                    return result\\\\n                else:\\\\n                    raise Exception(\\\\\\\"Submission status unclear\\\\\\\")\\\\n                \\\\n            except PlaywrightTimeout as e:\\\\n                logger.warning(f\\\\\\\"\u23f1\ufe0f Timeout on attempt {attempt + 1}: {e}\\\\\\\")\\\\n                result[\\\\\\\"errors\\\\\\\"].append(f\\\\\\\"Timeout: {str(e)}\\\\\\\")\\\\n                \\\\n            except Exception as e:\\\\n                logger.error(f\\\\\\\"\u274c Error on attempt {attempt + 1}: {e}\\\\\\\")\\\\n                result[\\\\\\\"errors\\\\\\\"].append(str(e))\\\\n                \\\\n                # Take error screenshot\\\\n                try:\\\\n                    await self._take_screenshot(f\\\\\\\"error_attempt_{attempt + 1}\\\\\\\")\\\\n                except Exception:\\\\n                    pass\\\\n            \\\\n            # Wait before retry\\\\n            if attempt < self.max_retries:\\\\n                logger.info(f\\\\\\\"\u23f3 Waiting {self.retry_delay}s",
    "error": "Unterminated string starting at: line 13 column 24 (char 453)"
  },
  "trained_from": {
    "documentation_docs": 12,
    "code_examples": 180,
    "recording_examples": 0
  },
  "training_cost": 0.0
}